<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Forsaken House | First-Person Horror</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            overflow: hidden;
            background-color: #000;
            color: #ddd;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }
        
        #health-container {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px 20px;
            border: 1px solid #600;
        }
        
        #health {
            color: #f00;
            font-size: 24px;
            font-weight: bold;
        }
        
        #sanctuary-bar {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px 20px;
            border: 1px solid #006;
        }
        
        #sanctuary {
            color: #66f;
            font-size: 24px;
            font-weight: bold;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 30px 50px;
            border-radius: 15px;
            border: 2px solid #800;
            text-align: center;
            max-width: 80%;
            font-size: 24px;
            color: #f44;
            z-index: 20;
            display: none;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.5);
        }
        
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.9), rgba(20, 0, 0, 0.9)), url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48cGF0dGVybiBpZD0iZ3JpZCIgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBwYXR0ZXJuVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSJNIDUwIDAgTCAwIDAgMCA1MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMjAwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=');
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #ddd;
            text-align: center;
            padding: 20px;
        }
        
        #title {
            font-size: 4rem;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #f00, 0 0 20px #800;
            letter-spacing: 3px;
        }
        
        #subtitle {
            font-size: 1.5rem;
            margin-bottom: 60px;
            color: #aaa;
        }
        
        #start-btn {
            background-color: #600;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            border: 2px solid #900;
        }
        
        #start-btn:hover {
            background-color: #900;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        
        #instructions {
            position: absolute;
            bottom: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            border: 1px solid #444;
            line-height: 1.6;
        }
        
        #instructions h3 {
            color: #b00;
            margin-bottom: 10px;
        }
        
        .key {
            display: inline-block;
            background-color: #333;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #555;
            font-family: monospace;
            margin: 0 5px;
        }
        
        #sound-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ddd;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            z-index: 40;
        }
        
        #sound-toggle:hover {
            background-color: rgba(50, 0, 0, 0.8);
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            text-align: center;
        }
        
        #game-over h2 {
            font-size: 4rem;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #f00;
        }
        
        #game-over p {
            font-size: 1.5rem;
            margin-bottom: 40px;
            max-width: 600px;
            line-height: 1.6;
        }
        
        #restart-btn {
            background-color: #600;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #900;
        }
        
        #restart-btn:hover {
            background-color: #900;
            transform: scale(1.05);
        }
        
        .flash {
            animation: flashEffect 0.3s;
        }
        
        @keyframes flashEffect {
            0% { background-color: rgba(255, 0, 0, 0.5); }
            100% { background-color: transparent; }
        }
        
        .pulse {
            animation: pulseEffect 2s infinite;
        }
        
        @keyframes pulseEffect {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        @media (max-width: 768px) {
            #title { font-size: 2.5rem; }
            #subtitle { font-size: 1.2rem; }
            #instructions { font-size: 0.9rem; padding: 15px; }
            .key { padding: 1px 5px; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div id="health-container">
                <div><i class="fas fa-heartbeat"></i> HEALTH</div>
                <div id="health">100</div>
            </div>
            <div id="sanctuary-bar">
                <div><i class="fas fa-cross"></i> SANCTUARY</div>
                <div id="sanctuary">3</div>
            </div>
        </div>
        
        <div id="message"></div>
        
        <div id="title-screen">
            <h1 id="title">THE FORSAKEN HOUSE</h1>
            <p id="subtitle">A First-Person Horror Experience</p>
            <p>You wake up in an old, abandoned house deep in the forest. Find a way out before the darkness consumes you.</p>
            <button id="start-btn">ENTER THE HOUSE</button>
            
            <div id="instructions">
                <h3>CONTROLS</h3>
                <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move around</p>
                <p><span class="key">MOUSE</span> - Look around</p>
                <p><span class="key">E</span> - Interact with objects</p>
                <p><span class="key">SPACE</span> - Use sanctuary (when available)</p>
                <p><span class="key">SHIFT</span> - Run (uses more stamina)</p>
                <p>Find the 4 keys to unlock the front door and escape!</p>
            </div>
        </div>
        
        <div id="game-over">
            <h2 id="game-over-title">GAME OVER</h2>
            <p id="game-over-text">The darkness has consumed you...</p>
            <button id="restart-btn">TRY AGAIN</button>
        </div>
        
        <button id="sound-toggle">
            <i class="fas fa-volume-up"></i> SOUND: ON
        </button>
    </div>

    <audio id="bg-audio" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-dark-ambience-927.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="scare-audio">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-horror-laugh-583.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="door-audio">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-creaky-door-opening-2585.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="footstep-audio">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-wood-floor-790.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="heartbeat-audio">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-heartbeat-fast-917.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="key-audio">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-keyboard-tap-1325.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('title-screen');
        const startBtn = document.getElementById('start-btn');
        const gameOverScreen = document.getElementById('game-over');
        const restartBtn = document.getElementById('restart-btn');
        const messageEl = document.getElementById('message');
        const healthEl = document.getElementById('health');
        const sanctuaryEl = document.getElementById('sanctuary');
        const soundToggle = document.getElementById('sound-toggle');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        let gameState = {
            started: false,
            gameOver: false,
            player: {
                x: 200,
                y: 200,
                angle: 0,
                health: 100,
                sanctuary: 3,
                keys: 0,
                maxKeys: 4,
                speed: 2,
                isRunning: false
            },
            map: [],
            mapWidth: 20,
            mapHeight: 20,
            rayCount: 300,
            fov: Math.PI / 3,
            wallHeight: 64,
            entities: [],
            lastTime: 0,
            deltaTime: 0,
            mouseSensitivity: 0.002,
            soundEnabled: true,
            messageTimeout: null,
            darkness: 0.7,
            flicker: 0
        };
        
        // Audio elements
        const bgAudio = document.getElementById('bg-audio');
        const scareAudio = document.getElementById('scare-audio');
        const doorAudio = document.getElementById('door-audio');
        const footstepAudio = document.getElementById('footstep-audio');
        const heartbeatAudio = document.getElementById('heartbeat-audio');
        const keyAudio = document.getElementById('key-audio');
        
        // Initialize game
        function init() {
            // Generate the house map
            generateMap();
            
            // Add entities (keys, doors, etc.)
            generateEntities();
            
            // Event listeners
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            soundToggle.addEventListener('click', toggleSound);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            document.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Start the game loop
            gameLoop(0);
            
            // Show a creepy message after a delay
            setTimeout(() => {
                showMessage("You shouldn't have come here...", 3000);
            }, 5000);
        }
        
        // Generate the house map
        function generateMap() {
            // Create empty map
            gameState.map = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                gameState.map[y] = [];
                for (let x = 0; x < gameState.mapWidth; x++) {
                    // Borders are walls
                    if (x === 0 || y === 0 || x === gameState.mapWidth - 1 || y === gameState.mapHeight - 1) {
                        gameState.map[y][x] = 1;
                    } else {
                        gameState.map[y][x] = 0;
                    }
                }
            }
            
            // Create rooms and corridors (simple house layout)
            // Main room
            for (let y = 2; y < 8; y++) {
                for (let x = 2; x < 8; x++) {
                    gameState.map[y][x] = 0;
                }
            }
            
            // Walls inside main room
            for (let x = 3; x < 7; x++) {
                gameState.map[5][x] = 1;
            }
            
            // Corridor
            for (let x = 8; x < 12; x++) {
                gameState.map[5][x] = 0;
            }
            
            // Second room
            for (let y = 2; y < 8; y++) {
                for (let x = 12; x < 18; x++) {
                    gameState.map[y][x] = 0;
                }
            }
            
            // Front door (exit) at the bottom
            gameState.map[gameState.mapHeight - 1][10] = 2;
            gameState.map[gameState.mapHeight - 1][9] = 0;
            gameState.map[gameState.mapHeight - 1][11] = 0;
            
            // Set player starting position
            gameState.player.x = 3.5;
            gameState.player.y = 3.5;
        }
        
        // Generate entities (keys, doors, etc.)
        function generateEntities() {
            gameState.entities = [];
            
            // Add keys at random positions
            const keyPositions = [
                {x: 4.5, y: 6.5},
                {x: 14.5, y: 3.5},
                {x: 6.5, y: 2.5},
                {x: 15.5, y: 6.5}
            ];
            
            keyPositions.forEach(pos => {
                gameState.entities.push({
                    type: 'key',
                    x: pos.x,
                    y: pos.y,
                    collected: false
                });
            });
            
            // Add a scary entity that moves around
            gameState.entities.push({
                type: 'entity',
                x: 14,
                y: 14,
                speed: 0.02,
                direction: Math.random() * Math.PI * 2,
                lastDirectionChange: 0
            });
            
            // Add interactive objects
            gameState.entities.push({
                type: 'book',
                x: 5.5,
                y: 3.5,
                interacted: false
            });
            
            gameState.entities.push({
                type: 'candle',
                x: 13.5,
                y: 5.5,
                lit: false
            });
        }
        
        // Start the game
        function startGame() {
            gameState.started = true;
            titleScreen.style.display = 'none';
            
            // Start audio
            if (gameState.soundEnabled) {
                bgAudio.volume = 0.3;
                bgAudio.play().catch(e => console.log("Audio play failed:", e));
            }
            
            // Request pointer lock for mouse controls
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
            
            // Show initial message
            showMessage("Find the keys to unlock the front door and escape!", 4000);
        }
        
        // Restart the game
        function restartGame() {
            gameState.gameOver = false;
            gameOverScreen.style.display = 'none';
            
            // Reset player
            gameState.player = {
                x: 3.5,
                y: 3.5,
                angle: 0,
                health: 100,
                sanctuary: 3,
                keys: 0,
                maxKeys: 4,
                speed: 2,
                isRunning: false
            };
            
            // Regenerate map and entities
            generateMap();
            generateEntities();
            
            // Update UI
            healthEl.textContent = gameState.player.health;
            sanctuaryEl.textContent = gameState.player.sanctuary;
            
            // Show message
            showMessage("You awaken once more in the forsaken house...", 3000);
        }
        
        // Toggle sound
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            soundToggle.innerHTML = gameState.soundEnabled ? 
                '<i class="fas fa-volume-up"></i> SOUND: ON' : 
                '<i class="fas fa-volume-mute"></i> SOUND: OFF';
            
            if (!gameState.soundEnabled) {
                bgAudio.pause();
            } else if (gameState.started && !gameState.gameOver) {
                bgAudio.play().catch(e => console.log("Audio play failed:", e));
            }
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            if (!gameState.started || gameState.gameOver) return;
            
            switch(e.key.toLowerCase()) {
                case 'w':
                    movePlayer(1);
                    break;
                case 's':
                    movePlayer(-1);
                    break;
                case 'a':
                    strafePlayer(-1);
                    break;
                case 'd':
                    strafePlayer(1);
                    break;
                case 'e':
                    interact();
                    break;
                case ' ':
                    useSanctuary();
                    break;
                case 'shift':
                    gameState.player.isRunning = true;
                    break;
            }
        }
        
        function handleKeyUp(e) {
            if (!gameState.started || gameState.gameOver) return;
            
            if (e.key.toLowerCase() === 'shift') {
                gameState.player.isRunning = false;
            }
        }
        
        // Handle mouse movement for looking around
        function handleMouseMove(e) {
            if (!gameState.started || gameState.gameOver) return;
            
            const movementX = e.movementX || e.mozMovementX || 0;
            gameState.player.angle += movementX * gameState.mouseSensitivity;
        }
        
        // Handle canvas click for interaction
        function handleCanvasClick() {
            if (!gameState.started || gameState.gameOver) return;
            
            // In a more advanced version, this could be used for attacking or special actions
        }
        
        // Move player forward/backward
        function movePlayer(direction) {
            const speed = gameState.player.isRunning ? gameState.player.speed * 1.5 : gameState.player.speed;
            const newX = gameState.player.x + Math.cos(gameState.player.angle) * speed * direction * gameState.deltaTime * 60;
            const newY = gameState.player.y + Math.sin(gameState.player.angle) * speed * direction * gameState.deltaTime * 60;
            
            if (!isCollision(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                
                // Play footstep sound occasionally
                if (gameState.soundEnabled && Math.random() < 0.1) {
                    footstepAudio.currentTime = 0;
                    footstepAudio.play().catch(e => console.log("Audio play failed:", e));
                }
            }
        }
        
        // Strafe player left/right
        function strafePlayer(direction) {
            const speed = gameState.player.isRunning ? gameState.player.speed * 1.5 : gameState.player.speed;
            const angle = gameState.player.angle + Math.PI/2;
            const newX = gameState.player.x + Math.cos(angle) * speed * direction * gameState.deltaTime * 60;
            const newY = gameState.player.y + Math.sin(angle) * speed * direction * gameState.deltaTime * 60;
            
            if (!isCollision(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                
                // Play footstep sound occasionally
                if (gameState.soundEnabled && Math.random() < 0.1) {
                    footstepAudio.currentTime = 0;
                    footstepAudio.play().catch(e => console.log("Audio play failed:", e));
                }
            }
        }
        
        // Check for collision with walls
        function isCollision(x, y) {
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            if (mapX < 0 || mapX >= gameState.mapWidth || mapY < 0 || mapY >= gameState.mapHeight) {
                return true;
            }
            
            return gameState.map[mapY][mapX] === 1;
        }
        
        // Interact with objects
        function interact() {
            // Check for nearby entities
            for (let entity of gameState.entities) {
                const dx = entity.x - gameState.player.x;
                const dy = entity.y - gameState.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 1.5) {
                    if (entity.type === 'key' && !entity.collected) {
                        entity.collected = true;
                        gameState.player.keys++;
                        showMessage(`You found a key! (${gameState.player.keys}/${gameState.player.maxKeys})`, 3000);
                        
                        if (gameState.soundEnabled) {
                            keyAudio.currentTime = 0;
                            keyAudio.play().catch(e => console.log("Audio play failed:", e));
                        }
                        
                        // Check if player has all keys
                        if (gameState.player.keys >= gameState.player.maxKeys) {
                            showMessage("You have all the keys! Find the front door to escape!", 5000);
                        }
                        return;
                    }
                    
                    if (entity.type === 'book' && !entity.interacted) {
                        entity.interacted = true;
                        showMessage("The book contains strange symbols. You feel a chill down your spine.", 4000);
                        return;
                    }
                    
                    if (entity.type === 'candle' && !entity.lit) {
                        entity.lit = true;
                        showMessage("You light the candle. The room feels slightly safer.", 3000);
                        // Increase light radius
                        gameState.darkness = 0.5;
                        return;
                    }
                }
            }
            
            // Check for front door
            const playerMapX = Math.floor(gameState.player.x);
            const playerMapY = Math.floor(gameState.player.y);
            
            if (playerMapY >= gameState.mapHeight - 2 && playerMapX >= 9 && playerMapX <= 11) {
                if (gameState.player.keys >= gameState.player.maxKeys) {
                    // Player escapes!
                    showMessage("You unlock the door and escape the forsaken house!", 5000);
                    
                    // Game win state
                    setTimeout(() => {
                        gameState.gameOver = true;
                        document.getElementById('game-over-title').textContent = "YOU ESCAPED!";
                        document.getElementById('game-over-text').textContent = "Against all odds, you managed to escape the forsaken house. But the forest still surrounds you...";
                        gameOverScreen.style.display = 'flex';
                    }, 3000);
                } else {
                    showMessage(`The door is locked. You need ${gameState.player.maxKeys - gameState.player.keys} more key(s).`, 3000);
                }
                
                if (gameState.soundEnabled) {
                    doorAudio.currentTime = 0;
                    doorAudio.play().catch(e => console.log("Audio play failed:", e));
                }
            }
        }
        
        // Use sanctuary (protective ability)
        function useSanctuary() {
            if (gameState.player.sanctuary > 0) {
                gameState.player.sanctuary--;
                sanctuaryEl.textContent = gameState.player.sanctuary;
                showMessage("You invoke a protective aura. The darkness recedes momentarily.", 3000);
                
                // Temporarily reduce darkness
                gameState.darkness = 0.3;
                setTimeout(() => {
                    gameState.darkness = 0.7;
                }, 5000);
                
                // Flash effect
                canvas.classList.add('flash');
                setTimeout(() => {
                    canvas.classList.remove('flash');
                }, 300);
            } else {
                showMessage("You have no sanctuary left to use!", 2000);
            }
        }
        
        // Show message on screen
        function showMessage(text, duration) {
            if (gameState.messageTimeout) {
                clearTimeout(gameState.messageTimeout);
            }
            
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            
            gameState.messageTimeout = setTimeout(() => {
                messageEl.style.display = 'none';
            }, duration);
        }
        
        // Update game logic
        function update() {
            if (!gameState.started || gameState.gameOver) return;
            
            // Update entities
            for (let entity of gameState.entities) {
                if (entity.type === 'entity') {
                    // Move entity
                    entity.x += Math.cos(entity.direction) * entity.speed * gameState.deltaTime * 60;
                    entity.y += Math.sin(entity.direction) * entity.speed * gameState.deltaTime * 60;
                    
                    // Change direction occasionally
                    entity.lastDirectionChange += gameState.deltaTime;
                    if (entity.lastDirectionChange > 2 + Math.random() * 3) {
                        entity.direction = Math.random() * Math.PI * 2;
                        entity.lastDirectionChange = 0;
                    }
                    
                    // Bounce off walls
                    if (isCollision(entity.x, entity.y)) {
                        entity.direction += Math.PI;
                        entity.x -= Math.cos(entity.direction) * entity.speed * gameState.deltaTime * 60;
                        entity.y -= Math.sin(entity.direction) * entity.speed * gameState.deltaTime * 60;
                    }
                    
                    // Check if entity is close to player
                    const dx = entity.x - gameState.player.x;
                    const dy = entity.y - gameState.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 3) {
                        // Entity is close, damage player occasionally
                        if (Math.random() < 0.01) {
                            gameState.player.health -= 5;
                            healthEl.textContent = gameState.player.health;
                            healthEl.classList.add('pulse');
                            
                            // Play scary sound
                            if (gameState.soundEnabled && Math.random() < 0.5) {
                                scareAudio.currentTime = 0;
                                scareAudio.play().catch(e => console.log("Audio play failed:", e));
                            }
                            
                            // Show message
                            showMessage("Something is nearby...", 2000);
                            
                            // Play heartbeat if health is low
                            if (gameState.player.health < 30 && gameState.soundEnabled) {
                                heartbeatAudio.volume = 0.5;
                                heartbeatAudio.play().catch(e => console.log("Audio play failed:", e));
                            }
                            
                            // Check for game over
                            if (gameState.player.health <= 0) {
                                gameState.player.health = 0;
                                healthEl.textContent = 0;
                                gameState.gameOver = true;
                                
                                setTimeout(() => {
                                    gameOverScreen.style.display = 'flex';
                                }, 1000);
                            }
                            
                            setTimeout(() => {
                                healthEl.classList.remove('pulse');
                            }, 1000);
                        }
                    }
                }
            }
            
            // Random events
            if (Math.random() < 0.001) {
                showMessage("You hear whispers in the distance...", 3000);
            }
            
            if (Math.random() < 0.0005) {
                showMessage("The walls seem to be closing in...", 3000);
                gameState.flicker = 10;
            }
            
            // Update flicker effect
            if (gameState.flicker > 0) {
                gameState.flicker--;
            }
        }
        
        // Render the game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.started) return;
            
            // Draw floor and ceiling
            const floorHeight = canvas.height / 2;
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, floorHeight);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, floorHeight, canvas.width, floorHeight);
            
            // Simple raycasting for walls
            const rayAngleIncrement = gameState.fov / gameState.rayCount;
            let rayAngle = gameState.player.angle - gameState.fov / 2;
            
            for (let i = 0; i < gameState.rayCount; i++) {
                // Cast ray
                let rayX = gameState.player.x;
                let rayY = gameState.player.y;
                let rayDirX = Math.cos(rayAngle);
                let rayDirY = Math.sin(rayAngle);
                
                let distance = 0;
                let hitWall = false;
                let wallType = 0;
                
                // DDA algorithm for raycasting
                while (!hitWall && distance < 20) {
                    distance += 0.1;
                    rayX = gameState.player.x + rayDirX * distance;
                    rayY = gameState.player.y + rayDirY * distance;
                    
                    const mapX = Math.floor(rayX);
                    const mapY = Math.floor(rayY);
                    
                    if (mapX < 0 || mapX >= gameState.mapWidth || mapY < 0 || mapY >= gameState.mapHeight) {
                        hitWall = true;
                        wallType = 1;
                    } else if (gameState.map[mapY][mapX] > 0) {
                        hitWall = true;
                        wallType = gameState.map[mapY][mapX];
                    }
                }
                
                // Fix fisheye effect
                const correctedDistance = distance * Math.cos(rayAngle - gameState.player.angle);
                
                // Calculate wall height
                const wallHeight = Math.min((gameState.wallHeight / correctedDistance) * 300, canvas.height);
                
                // Draw wall slice
                const wallTop = floorHeight - wallHeight / 2;
                const wallBottom = wallTop + wallHeight;
                
                // Determine wall color based on type and distance
                let wallColor;
                if (wallType === 1) {
                    // Regular wall
                    const darkness = Math.min(1, correctedDistance / 10);
                    wallColor = `rgb(${70 - darkness * 40}, ${50 - darkness * 40}, ${30 - darkness * 30})`;
                } else if (wallType === 2) {
                    // Door
                    wallColor = `rgb(100, 70, 40)`;
                } else {
                    // Default
                    wallColor = `rgb(80, 60, 40)`;
                }
                
                ctx.fillStyle = wallColor;
                ctx.fillRect(i * (canvas.width / gameState.rayCount), wallTop, canvas.width / gameState.rayCount + 1, wallHeight);
                
                // Add texture with subtle noise
                if (wallType > 0) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 + Math.random() * 0.2})`;
                    ctx.fillRect(i * (canvas.width / gameState.rayCount), wallTop, canvas.width / gameState.rayCount + 1, wallHeight);
                }
                
                rayAngle += rayAngleIncrement;
            }
            
            // Draw entities
            for (let entity of gameState.entities) {
                if (entity.type === 'key' && !entity.collected) {
                    // Calculate position on screen
                    const dx = entity.x - gameState.player.x;
                    const dy = entity.y - gameState.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Only draw if in front of player
                    const angleToEntity = Math.atan2(dy, dx);
                    let angleDiff = angleToEntity - gameState.player.angle;
                    
                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Check if entity is within field of view
                    if (Math.abs(angleDiff) < gameState.fov / 2 && distance < 10) {
                        // Calculate screen position
                        const screenX = (angleDiff + gameState.fov / 2) / gameState.fov * canvas.width;
                        const size = Math.max(10, 100 / distance);
                        
                        // Draw key
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `${Math.max(10, size/3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('K', screenX, canvas.height / 2 + size/6);
                    }
                }
                
                if (entity.type === 'entity') {
                    // Calculate position on screen
                    const dx = entity.x - gameState.player.x;
                    const dy = entity.y - gameState.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Only draw if in front of player
                    const angleToEntity = Math.atan2(dy, dx);
                    let angleDiff = angleToEntity - gameState.player.angle;
                    
                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Check if entity is within field of view
                    if (Math.abs(angleDiff) < gameState.fov / 2 && distance < 10) {
                        // Calculate screen position
                        const screenX = (angleDiff + gameState.fov / 2) / gameState.fov * canvas.width;
                        const size = Math.max(20, 150 / distance);
                        
                        // Draw entity as a red circle
                        ctx.fillStyle = `rgba(150, 0, 0, ${0.7 - distance/15})`;
                        ctx.beginPath();
                        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add glowing effect
                        ctx.fillStyle = `rgba(255, 0, 0, ${0.3 - distance/30})`;
                        ctx.beginPath();
                        ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Apply darkness overlay
            const darknessAlpha = gameState.darkness + (gameState.flicker > 0 ? Math.random() * 0.2 : 0);
            ctx.fillStyle = `rgba(0, 0, 0, ${darknessAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw key counter
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(20, canvas.height - 60, 200, 40);
            ctx.fillStyle = '#ffd700';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`KEYS: ${gameState.player.keys}/${gameState.player.maxKeys}`, 40, canvas.height - 35);
            
            // Draw instruction reminder
            if (gameState.player.keys < gameState.player.maxKeys) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Find keys to unlock the front door', canvas.width / 2, canvas.height - 20);
            } else {
                ctx.fillStyle = 'rgba(0, 100, 0, 0.7)';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('You have all keys! Find the front door to escape!', canvas.width / 2, canvas.height - 20);
            }
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            // Calculate delta time
            if (!gameState.lastTime) gameState.lastTime = timestamp;
            gameState.deltaTime = (timestamp - gameState.lastTime) / 1000;
            gameState.lastTime = timestamp;
            
            // Update and render
            update();
            render();
            
            // Continue the loop
            requestAnimationFrame(gameLoop);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Initialize the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
