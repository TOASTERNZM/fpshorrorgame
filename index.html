<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forsaken Manor | Horror Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #fff;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #600;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #a00, #f00);
            transition: width 0.3s;
        }
        
        #health-text {
            position: absolute;
            top: 20px;
            left: 230px;
            font-size: 20px;
            color: #f00;
            text-shadow: 0 0 5px #000;
        }
        
        #keys {
            position: absolute;
            top: 60px;
            left: 20px;
            font-size: 18px;
            color: #ff0;
            text-shadow: 0 0 5px #000;
        }
        
        #sanctuary {
            position: absolute;
            top: 90px;
            left: 20px;
            font-size: 18px;
            color: #0af;
            text-shadow: 0 0 5px #000;
        }
        
        #enemy-warning {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #objective {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 18px;
            color: #0f0;
            text-shadow: 0 0 5px #000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
        }
        
        #game-over, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        #game-over h1, #win-screen h1 {
            font-size: 60px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #f00;
        }
        
        #win-screen h1 {
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
        }
        
        #restart-btn, #continue-btn {
            background: #600;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            margin-top: 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        #restart-btn:hover, #continue-btn:hover {
            background: #900;
            transform: scale(1.05);
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.9), rgba(20, 0, 0, 0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        
        #title {
            font-size: 80px;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
            letter-spacing: 5px;
        }
        
        #start-btn {
            background: #800;
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 28px;
            margin-top: 40px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            border: 2px solid #a00;
        }
        
        #start-btn:hover {
            background: #a00;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            text-align: center;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 5px;
            border: 1px solid #555;
            font-family: monospace;
        }
        
        #sound-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #555;
            padding: 10px;
            cursor: pointer;
            z-index: 40;
            border-radius: 5px;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        .crosshair::after {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #f00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="health-text">HEALTH: 100</div>
            <div id="keys">KEYS: 0/4</div>
            <div id="sanctuary">SANCTUARY: 3</div>
            <div id="enemy-warning">IT'S CLOSE!</div>
            <div id="objective">Find 4 keys to unlock the front door</div>
            <div class="crosshair"></div>
        </div>
        
        <div id="start-screen">
            <h1 id="title">FORSAKEN MANOR</h1>
            <p style="font-size: 24px; margin-bottom: 40px; text-align: center; max-width: 800px;">
                You wake up in an abandoned manor deep in the forest.<br>
                Something is hunting you. Find the keys and escape.
            </p>
            <button id="start-btn">BEGIN NIGHTMARE</button>
            <div id="controls">
                <p><span class="key">WASD</span> Move | <span class="key">MOUSE</span> Look | <span class="key">E</span> Interact</p>
                <p><span class="key">SHIFT</span> Run | <span class="key">SPACE</span> Use Sanctuary | <span class="key">F</span> Flashlight</p>
            </div>
        </div>
        
        <div id="game-over">
            <h1>YOU DIED</h1>
            <p style="font-size: 24px; margin-bottom: 20px;">The creature has caught you...</p>
            <button id="restart-btn">TRY AGAIN</button>
        </div>
        
        <div id="win-screen">
            <h1>ESCAPED!</h1>
            <p style="font-size: 24px; margin-bottom: 20px; text-align: center; max-width: 600px;">
                You managed to escape the forsaken manor,<br>
                but the creature's screams still echo in the forest...
            </p>
            <button id="continue-btn">PLAY AGAIN</button>
        </div>
        
        <div id="loading">
            <div class="spinner"></div>
            <div>LOADING NIGHTMARE...</div>
        </div>
        
        <button id="sound-toggle">ðŸ”Š SOUND ON</button>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const winScreen = document.getElementById('win-screen');
        const loadingScreen = document.getElementById('loading');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const continueBtn = document.getElementById('continue-btn');
        const soundToggle = document.getElementById('sound-toggle');
        const healthFill = document.getElementById('health-fill');
        const healthText = document.getElementById('health-text');
        const keysText = document.getElementById('keys');
        const sanctuaryText = document.getElementById('sanctuary');
        const enemyWarning = document.getElementById('enemy-warning');
        const objectiveText = document.getElementById('objective');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        const gameState = {
            started: false,
            gameOver: false,
            won: false,
            player: {
                x: 300,
                y: 300,
                angle: 0,
                health: 100,
                keys: 0,
                maxKeys: 4,
                sanctuary: 3,
                speed: 3,
                isRunning: false,
                hasFlashlight: true,
                flashlightOn: false,
                stamina: 100
            },
            enemy: {
                x: 800,
                y: 800,
                speed: 1.5,
                chasing: false,
                lastSeenTime: 0,
                detectionRadius: 200,
                chaseRadius: 400,
                attackRadius: 30
            },
            house: {
                walls: [],
                doors: [],
                windows: [],
                furniture: []
            },
            keys: [],
            lastTime: 0,
            deltaTime: 0,
            mouseSensitivity: 0.002,
            soundEnabled: true,
            darkness: 0.85,
            flicker: 0,
            enemyDistance: 1000
        };

        // Initialize game
        function init() {
            // Build the house
            buildHouse();
            
            // Place keys in the house
            placeKeys();
            
            // Event listeners
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            continueBtn.addEventListener('click', restartGame);
            soundToggle.addEventListener('click', toggleSound);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            document.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Hide loading screen
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                startScreen.style.display = 'flex';
            }, 1500);
            
            // Start game loop
            gameLoop(0);
        }

        // Build the house model
        function buildHouse() {
            // Clear previous house
            gameState.house.walls = [];
            gameState.house.doors = [];
            gameState.house.windows = [];
            gameState.house.furniture = [];
            
            // Define house layout (walls as rectangles)
            // Outer walls
            gameState.house.walls.push({x: 200, y: 200, width: 800, height: 30}); // top
            gameState.house.walls.push({x: 200, y: 570, width: 800, height: 30}); // bottom
            gameState.house.walls.push({x: 200, y: 200, width: 30, height: 400}); // left
            gameState.house.walls.push({x: 970, y: 200, width: 30, height: 400}); // right
            
            // Interior walls
            gameState.house.walls.push({x: 200, y: 350, width: 300, height: 30}); // hallway wall
            gameState.house.walls.push({x: 500, y: 350, width: 30, height: 250}); // room divider
            gameState.house.walls.push({x: 500, y: 350, width: 300, height: 30}); // middle wall
            gameState.house.walls.push({x: 700, y: 200, width: 30, height: 180}); // right room divider
            
            // Doors
            gameState.house.doors.push({x: 470, y: 570, width: 60, height: 30, locked: true}); // front door
            gameState.house.doors.push({x: 500, y: 320, width: 30, height: 60, locked: false}); // interior door
            
            // Windows
            gameState.house.windows.push({x: 300, y: 190, width: 100, height: 10});
            gameState.house.windows.push({x: 600, y: 190, width: 100, height: 10});
            gameState.house.windows.push({x: 850, y: 300, width: 10, height: 100});
            
            // Furniture
            gameState.house.furniture.push({x: 250, y: 250, width: 80, height: 60, type: 'table'});
            gameState.house.furniture.push({x: 350, y: 250, width: 60, height: 80, type: 'cabinet'});
            gameState.house.furniture.push({x: 600, y: 250, width: 120, height: 60, type: 'bed'});
            gameState.house.furniture.push({x: 800, y: 250, width: 80, height: 100, type: 'wardrobe'});
            gameState.house.furniture.push({x: 250, y: 450, width: 100, height: 80, type: 'sofa'});
            gameState.house.furniture.push({x: 650, y: 450, width: 80, height: 80, type: 'chest'});
            
            // Set player start position
            gameState.player.x = 300;
            gameState.player.y = 320;
            gameState.player.angle = 0;
            
            // Set enemy start position
            gameState.enemy.x = 850;
            gameState.enemy.y = 450;
        }

        // Place keys in the house
        function placeKeys() {
            gameState.keys = [
                {x: 280, y: 280, collected: false},
                {x: 620, y: 280, collected: false},
                {x: 820, y: 280, collected: false},
                {x: 670, y: 470, collected: false}
            ];
        }

        // Start the game
        function startGame() {
            gameState.started = true;
            startScreen.style.display = 'none';
            
            // Request pointer lock for mouse controls
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
        }

        // Restart the game
        function restartGame() {
            gameState.gameOver = false;
            gameState.won = false;
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            
            // Reset player
            gameState.player = {
                x: 300,
                y: 320,
                angle: 0,
                health: 100,
                keys: 0,
                maxKeys: 4,
                sanctuary: 3,
                speed: 3,
                isRunning: false,
                hasFlashlight: true,
                flashlightOn: false,
                stamina: 100
            };
            
            // Reset enemy
            gameState.enemy = {
                x: 850,
                y: 450,
                speed: 1.5,
                chasing: false,
                lastSeenTime: 0,
                detectionRadius: 200,
                chaseRadius: 400,
                attackRadius: 30
            };
            
            // Reset keys
            placeKeys();
            
            // Update UI
            updateUI();
        }

        // Toggle sound
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            soundToggle.textContent = gameState.soundEnabled ? 'ðŸ”Š SOUND ON' : 'ðŸ”‡ SOUND OFF';
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            if (!gameState.started || gameState.gameOver || gameState.won) return;
            
            switch(e.key.toLowerCase()) {
                case 'w':
                    movePlayer(1);
                    break;
                case 's':
                    movePlayer(-1);
                    break;
                case 'a':
                    strafePlayer(-1);
                    break;
                case 'd':
                    strafePlayer(1);
                    break;
                case 'shift':
                    gameState.player.isRunning = true;
                    break;
                case 'e':
                    interact();
                    break;
                case ' ':
                    useSanctuary();
                    break;
                case 'f':
                    toggleFlashlight();
                    break;
            }
        }

        function handleKeyUp(e) {
            if (!gameState.started) return;
            
            if (e.key.toLowerCase() === 'shift') {
                gameState.player.isRunning = false;
            }
        }

        // Handle mouse movement
        function handleMouseMove(e) {
            if (!gameState.started || gameState.gameOver || gameState.won) return;
            
            const movementX = e.movementX || e.mozMovementX || 0;
            gameState.player.angle += movementX * gameState.mouseSensitivity;
            
            // Keep angle within reasonable bounds
            if (gameState.player.angle > Math.PI * 2) gameState.player.angle -= Math.PI * 2;
            if (gameState.player.angle < 0) gameState.player.angle += Math.PI * 2;
        }

        // Handle canvas click
        function handleCanvasClick() {
            if (!gameState.started || gameState.gameOver || gameState.won) return;
            // Can be used for attacks or special actions
        }

        // Move player forward/backward
        function movePlayer(direction) {
            const speed = gameState.player.isRunning ? gameState.player.speed * 1.8 : gameState.player.speed;
            const moveX = Math.cos(gameState.player.angle) * speed * direction * gameState.deltaTime * 60;
            const moveY = Math.sin(gameState.player.angle) * speed * direction * gameState.deltaTime * 60;
            
            const newX = gameState.player.x + moveX;
            const newY = gameState.player.y + moveY;
            
            if (!checkCollision(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                
                // Update stamina if running
                if (gameState.player.isRunning && direction > 0) {
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - 0.5);
                    if (gameState.player.stamina === 0) {
                        gameState.player.isRunning = false;
                    }
                } else if (!gameState.player.isRunning) {
                    gameState.player.stamina = Math.min(100, gameState.player.stamina + 0.2);
                }
            }
        }

        // Strafe player
        function strafePlayer(direction) {
            const speed = gameState.player.isRunning ? gameState.player.speed * 1.5 : gameState.player.speed;
            const angle = gameState.player.angle + Math.PI/2;
            const moveX = Math.cos(angle) * speed * direction * gameState.deltaTime * 60;
            const moveY = Math.sin(angle) * speed * direction * gameState.deltaTime * 60;
            
            const newX = gameState.player.x + moveX;
            const newY = gameState.player.y + moveY;
            
            if (!checkCollision(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
            }
        }

        // Check collision with walls and furniture
        function checkCollision(x, y) {
            const playerRadius = 15;
            
            // Check walls
            for (const wall of gameState.house.walls) {
                if (x + playerRadius > wall.x && x - playerRadius < wall.x + wall.width &&
                    y + playerRadius > wall.y && y - playerRadius < wall.y + wall.height) {
                    return true;
                }
            }
            
            // Check furniture
            for (const furniture of gameState.house.furniture) {
                if (x + playerRadius > furniture.x && x - playerRadius < furniture.x + furniture.width &&
                    y + playerRadius > furniture.y && y - playerRadius < furniture.y + furniture.height) {
                    return true;
                }
            }
            
            return false;
        }

        // Interact with objects
        function interact() {
            // Check for keys
            for (const key of gameState.keys) {
                if (!key.collected) {
                    const dx = key.x - gameState.player.x;
                    const dy = key.y - gameState.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 50) {
                        key.collected = true;
                        gameState.player.keys++;
                        updateUI();
                        
                        // Update objective
                        if (gameState.player.keys === gameState.player.maxKeys) {
                            objectiveText.textContent = "Find the front door and escape!";
                            objectiveText.style.color = "#0f0";
                        } else {
                            objectiveText.textContent = `Keys found: ${gameState.player.keys}/${gameState.player.maxKeys}`;
                        }
                        return;
                    }
                }
            }
            
            // Check for front door
            const frontDoor = gameState.house.doors[0];
            const dx = frontDoor.x + frontDoor.width/2 - gameState.player.x;
            const dy = frontDoor.y + frontDoor.height/2 - gameState.player.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < 60) {
                if (gameState.player.keys >= gameState.player.maxKeys) {
                    // Win the game
                    gameState.won = true;
                    winScreen.style.display = 'flex';
                } else {
                    objectiveText.textContent = `Need ${gameState.player.maxKeys - gameState.player.keys} more key(s) to unlock`;
                    objectiveText.style.color = "#f00";
                    setTimeout(() => {
                        if (gameState.player.keys === gameState.player.maxKeys) {
                            objectiveText.textContent = "Find the front door and escape!";
                            objectiveText.style.color = "#0f0";
                        } else {
                            objectiveText.textContent = `Keys found: ${gameState.player.keys}/${gameState.player.maxKeys}`;
                            objectiveText.style.color = "#0f0";
                        }
                    }, 2000);
                }
            }
        }

        // Use sanctuary (protective ability)
        function useSanctuary() {
            if (gameState.player.sanctuary > 0 && gameState.enemy.chasing) {
                gameState.player.sanctuary--;
                gameState.enemy.chasing = false;
                gameState.enemy.x = 850;
                gameState.enemy.y = 450;
                updateUI();
                
                // Visual effect
                gameState.darkness = 0.5;
                setTimeout(() => {
                    gameState.darkness = 0.85;
                }, 1000);
            }
        }

        // Toggle flashlight
        function toggleFlashlight() {
            if (gameState.player.hasFlashlight) {
                gameState.player.flashlightOn = !gameState.player.flashlightOn;
                gameState.darkness = gameState.player.flashlightOn ? 0.4 : 0.85;
            }
        }

        // Update enemy AI
        function updateEnemy() {
            const dx = gameState.player.x - gameState.enemy.x;
            const dy = gameState.player.y - gameState.enemy.y;
            gameState.enemyDistance = Math.sqrt(dx*dx + dy*dy);
            
            // Update enemy warning
            if (gameState.enemyDistance < 150 && gameState.enemy.chasing) {
                enemyWarning.style.opacity = 1;
                const intensity = 1 - (gameState.enemyDistance / 150);
                enemyWarning.style.fontSize = 24 + intensity * 16 + 'px';
                enemyWarning.style.textShadow = `0 0 ${10 + intensity * 20}px #f00`;
            } else {
                enemyWarning.style.opacity = 0;
            }
            
            // Check if player is detected
            if (!gameState.enemy.chasing) {
                if (gameState.enemyDistance < gameState.enemy.detectionRadius) {
                    gameState.enemy.chasing = true;
                    gameState.enemy.lastSeenTime = Date.now();
                }
            } else {
                // Continue chasing or give up after 10 seconds
                if (Date.now() - gameState.enemy.lastSeenTime > 10000) {
                    gameState.enemy.chasing = false;
                } else {
                    // Move towards player
                    const angle = Math.atan2(dy, dx);
                    const speed = gameState.enemy.speed * gameState.deltaTime * 60;
                    
                    gameState.enemy.x += Math.cos(angle) * speed;
                    gameState.enemy.y += Math.sin(angle) * speed;
                    
                    // Check for attack
                    if (gameState.enemyDistance < gameState.enemy.attackRadius) {
                        attackPlayer();
                    }
                    
                    // Update last seen time if player is still in chase radius
                    if (gameState.enemyDistance < gameState.enemy.chaseRadius) {
                        gameState.enemy.lastSeenTime = Date.now();
                    }
                }
            }
        }

        // Attack player
        function attackPlayer() {
            gameState.player.health -= 20;
            updateUI();
            
            // Visual feedback
            canvas.style.backgroundColor = '#f00';
            setTimeout(() => {
                canvas.style.backgroundColor = '#000';
            }, 100);
            
            // Check for game over
            if (gameState.player.health <= 0) {
                gameState.player.health = 0;
                gameState.gameOver = true;
                gameOverScreen.style.display = 'flex';
            }
        }

        // Update UI
        function updateUI() {
            healthFill.style.width = gameState.player.health + '%';
            healthText.textContent = 'HEALTH: ' + Math.max(0, gameState.player.health);
            keysText.textContent = 'KEYS: ' + gameState.player.keys + '/' + gameState.player.maxKeys;
            sanctuaryText.textContent = 'SANCTUARY: ' + gameState.player.sanctuary;
            
            // Update health color based on value
            if (gameState.player.health > 60) {
                healthFill.style.background = 'linear-gradient(to right, #0a0, #0f0)';
            } else if (gameState.player.health > 30) {
                healthFill.style.background = 'linear-gradient(to right, #a60, #fa0)';
            } else {
                healthFill.style.background = 'linear-gradient(to right, #a00, #f00)';
            }
        }

        // Draw the game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.started) return;
            
            // Draw from player's perspective
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw floor (simple gradient)
            const floorGradient = ctx.createLinearGradient(0, centerY, 0, canvas.height);
            floorGradient.addColorStop(0, '#222');
            floorGradient.addColorStop(1, '#111');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, centerY, canvas.width, canvas.height - centerY);
            
            // Draw ceiling
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, centerY);
            ceilingGradient.addColorStop(0, '#111');
            ceilingGradient.addColorStop(1, '#222');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, centerY);
            
            // Draw house from player's perspective (simplified 3D)
            drawWalls();
            drawDoors();
            drawWindows();
            drawFurniture();
            drawKeys();
            drawEnemy();
            
            // Apply darkness overlay
            ctx.fillStyle = `rgba(0, 0, 0, ${gameState.darkness})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw flashlight effect if on
            if (gameState.player.flashlightOn) {
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 50,
                    centerX, centerY, 400
                );
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw stamina bar
            if (gameState.player.isRunning) {
                ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
                ctx.fillRect(canvas.width - 220, 20, 200 * (gameState.player.stamina / 100), 20);
                ctx.strokeStyle = '#0af';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 220, 20, 200, 20);
                
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('STAMINA', canvas.width - 230, 35);
            }
        }

        // Draw walls from player's perspective
        function drawWalls() {
            ctx.fillStyle = '#8B4513'; // Brown wood color
            
            for (const wall of gameState.house.walls) {
                // Convert world position to screen position relative to player
                const dx = wall.x - gameState.player.x;
                const dy = wall.y - gameState.player.y;
                
                // Calculate distance and angle
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                // Simple perspective projection
                const screenX = canvas.width / 2 + (angle * 200);
                const height = Math.max(10, 5000 / distance);
                const width = Math.max(10, wall.width * 100 / distance);
                
                // Draw wall if it's in front of player
                if (distance < 500 && Math.abs(angle) < Math.PI / 2) {
                    const y = canvas.height / 2 - height / 2;
                    
                    // Draw wall with texture
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(screenX - width/2, y, width, height);
                    
                    // Add wood texture
                    ctx.fillStyle = '#A0522D';
                    for (let i = 0; i < 5; i++) {
                        const lineY = y + i * (height / 5);
                        ctx.fillRect(screenX - width/2, lineY, width, 2);
                    }
                }
            }
        }

        // Draw other elements (simplified)
        function drawDoors() {
            ctx.fillStyle = '#654321';
            for (const door of gameState.house.doors) {
                const dx = door.x - gameState.player.x;
                const dy = door.y - gameState.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx) - gameState.player.angle;
                
                if (distance < 500 && Math.abs(angle) < Math.PI / 2) {
                    const screenX = canvas.width / 2 + (angle * 200);
                    const height = Math.max(20, 4000 / distance);
                    const width = Math.max(10, door.width * 80 / distance);
                    const y = canvas.height / 2 - height / 2;
                    
                    ctx.fillRect(screenX - width/2, y, width, height);
                    
                    // Draw doorknob
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(screenX - width/4, y + height/2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#654321';
                }
            }
        }

        function drawWindows() {
            ctx.fillStyle = '#0af';
            for (const window of gameState.house.windows) {
                const dx = window.x - gameState.player.x;
                const dy = window.y - gameState.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 300) {
                    const angle = Math.atan2(dy, dx) - gameState.player.angle;
                    if (Math.abs(angle) < Math.PI / 2) {
                        const screenX = canvas.width / 2 + (angle * 200);
                        const size = Math.max(5, 100 / distance);
                        
                        ctx.fillRect(screenX - size/2, canvas.height/2 - size/2, size, size);
                    }
                }
            }
        }

        function drawFurniture() {
            for (const furniture of gameState.house.furniture)
