<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forsaken Manor | 3D Horror Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .hud-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #444;
            min-width: 200px;
        }
        
        .hud-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        #health .hud-value { color: #f00; }
        #keys .hud-value { color: #ff0; }
        #sanctuary .hud-value { color: #0af; }
        
        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #f00;
            text-shadow: 0 0 20px #f00;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            border: 3px solid #f00;
            display: none;
            z-index: 20;
        }
        
        #objective {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #0a0;
            color: #0f0;
            font-size: 18px;
            max-width: 600px;
            text-align: center;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.95), rgba(20, 0, 0, 0.95));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        
        #title {
            font-size: 72px;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
            letter-spacing: 5px;
        }
        
        #subtitle {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 60px;
            max-width: 800px;
            text-align: center;
            line-height: 1.5;
        }
        
        #start-btn {
            background: #800;
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 28px;
            cursor: pointer;
            border-radius: 10px;
            margin-top: 30px;
            border: 2px solid #a00;
            transition: all 0.3s;
        }
        
        #start-btn:hover {
            background: #a00;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }
        
        #controls {
            position: absolute;
            bottom: 40px;
            background: rgba(0, 0, 0, 0.8);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 500px;
            line-height: 1.8;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 5px;
            border: 1px solid #555;
            font-family: monospace;
        }
        
        #game-over, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 40;
        }
        
        #game-over h1 {
            font-size: 72px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #f00;
        }
        
        #win-screen h1 {
            font-size: 72px;
            color: #0f0;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0f0;
        }
        
        #restart-btn, #continue-btn {
            background: #600;
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 10px;
            margin-top: 40px;
            border: 2px solid #800;
            transition: all 0.3s;
        }
        
        #restart-btn:hover, #continue-btn:hover {
            background: #800;
            transform: scale(1.05);
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair:before, .crosshair:after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .crosshair:before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        .crosshair:after {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #sound-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            z-index: 50;
            border-radius: 5px;
        }
        
        #flashlight-icon {
            position: absolute;
            top: 20px;
            right: 150px;
            background: rgba(0, 0, 0, 0.7);
            color: #ff0;
            border: 1px solid #660;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #stamina-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #0af;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #stamina-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #0af, #0ff);
            transition: width 0.3s;
        }
        
        .pulse {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="hud">
                <div id="health" class="hud-item">
                    <div>HEALTH</div>
                    <div class="hud-value">100</div>
                </div>
                <div id="keys" class="hud-item">
                    <div>KEYS FOUND</div>
                    <div class="hud-value">0/5</div>
                </div>
                <div id="sanctuary" class="hud-item">
                    <div>SANCTUARY</div>
                    <div class="hud-value">3</div>
                </div>
            </div>
            
            <div id="warning">IT'S CLOSE!</div>
            <div id="objective">Find 5 keys scattered in the house to unlock the front door</div>
            <div class="crosshair"></div>
            
            <div id="flashlight-icon">
                <span>ðŸ”¦</span> FLASHLIGHT: ON
            </div>
            
            <div id="stamina-bar">
                <div id="stamina-fill"></div>
            </div>
        </div>
        
        <div id="start-screen">
            <h1 id="title">THE FORSAKEN MANOR</h1>
            <p id="subtitle">
                You wake up in an abandoned manor deep in the Blackwood Forest.<br>
                Your flashlight is fading, and something is hunting you in the dark.<br>
                Find the keys and escape before it's too late.
            </p>
            <button id="start-btn">ENTER THE MANOR</button>
            
            <div id="controls">
                <p><span class="key">WASD</span> Move | <span class="key">MOUSE</span> Look Around</p>
                <p><span class="key">SHIFT</span> Run | <span class="key">F</span> Toggle Flashlight</p>
                <p><span class="key">E</span> Interact / Pick Up | <span class="key">SPACE</span> Use Sanctuary</p>
                <p><span class="key">ESC</span> Pause / Menu</p>
            </div>
        </div>
        
        <div id="game-over">
            <h1>YOU DIED</h1>
            <p style="font-size: 24px; margin-bottom: 20px;">The darkness has consumed you...</p>
            <button id="restart-btn">TRY AGAIN</button>
        </div>
        
        <div id="win-screen">
            <h1>ESCAPED!</h1>
            <p style="font-size: 24px; margin-bottom: 20px; text-align: center; max-width: 600px;">
                You managed to escape the forsaken manor,<br>
                but the creature's screams still echo through the forest...
            </p>
            <button id="continue-btn">PLAY AGAIN</button>
        </div>
        
        <button id="sound-toggle">ðŸ”Š SOUND ON</button>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const winScreen = document.getElementById('win-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const continueBtn = document.getElementById('continue-btn');
        const soundToggle = document.getElementById('sound-toggle');
        const warningEl = document.getElementById('warning');
        const objectiveEl = document.getElementById('objective');
        const healthValue = document.querySelector('#health .hud-value');
        const keysValue = document.querySelector('#keys .hud-value');
        const sanctuaryValue = document.querySelector('#sanctuary .hud-value');
        const flashlightIcon = document.getElementById('flashlight-icon');
        const staminaFill = document.getElementById('stamina-fill');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        const game = {
            started: false,
            gameOver: false,
            won: false,
            player: {
                x: 400,
                y: 300,
                z: 50,
                angle: 0,
                tilt: 0,
                health: 100,
                keys: 0,
                maxKeys: 5,
                sanctuary: 3,
                speed: 2.5,
                isRunning: false,
                hasFlashlight: true,
                flashlightOn: true,
                stamina: 100,
                maxStamina: 100
            },
            enemy: {
                x: 900,
                y: 600,
                z: 50,
                speed: 1.5,
                chasing: false,
                detectionRange: 300,
                chaseRange: 600,
                attackRange: 40,
                lastSeenTime: 0
            },
            house: {
                rooms: [],
                walls: [],
                floors: [],
                ceilings: [],
                doors: [],
                windows: [],
                furniture: []
            },
            keys: [],
            darkness: 0.8,
            lastTime: 0,
            keysPressed: {},
            mouseSensitivity: 0.002,
            soundEnabled: true,
            enemyDistance: 1000
        };
        
        // Initialize game
        function init() {
            // Build the 3D house
            buildHouse();
            
            // Set up event listeners
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            continueBtn.addEventListener('click', restartGame);
            soundToggle.addEventListener('click', toggleSound);
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            document.addEventListener('mousemove', handleMouseMove);
            
            document.addEventListener('click', () => {
                if (game.started && !game.gameOver && !game.won) {
                    canvas.requestPointerLock();
                }
            });
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Build the 3D house
        function buildHouse() {
            // Clear previous house
            game.house = {
                rooms: [],
                walls: [],
                floors: [],
                ceilings: [],
                doors: [],
                windows: [],
                furniture: []
            };
            
            // House layout
            const houseLayout = {
                // Main rooms with full 3D coordinates
                rooms: [
                    // Entry Hall (10x10 meters)
                    {x: 0, y: 0, width: 1000, height: 1000, height3D: 400},
                    // Living Room (12x8 meters)
                    {x: 1000, y: 0, width: 1200, height: 800, height3D: 400},
                    // Kitchen (8x8 meters)
                    {x: 0, y: 1000, width: 800, height: 800, height3D: 400},
                    // Study (8x6 meters)
                    {x: 1000, y: 800, width: 800, height: 600, height3D: 400},
                    // Hallway
                    {x: 800, y: 0, width: 200, height: 1800, height3D: 400}
                ]
            };
            
            // Build walls for each room
            houseLayout.rooms.forEach(room => {
                // Floor
                game.house.floors.push({
                    x: room.x, y: room.y, z: 0,
                    width: room.width, height: room.height,
                    color: '#8B4513' // Wood color
                });
                
                // Ceiling
                game.house.ceilings.push({
                    x: room.x, y: room.y, z: room.height3D,
                    width: room.width, height: room.height,
                    color: '#696969' // Dark gray
                });
                
                // Walls (4 walls per room)
                // North wall
                game.house.walls.push({
                    x: room.x, y: room.y, z: 0,
                    width: room.width, height: room.height3D,
                    color: '#A0522D',
                    type: 'north'
                });
                
                // South wall
                game.house.walls.push({
                    x: room.x, y: room.y + room.height, z: 0,
                    width: room.width, height: room.height3D,
                    color: '#A0522D',
                    type: 'south'
                });
                
                // West wall
                game.house.walls.push({
                    x: room.x, y: room.y, z: 0,
                    width: room.height3D, height: room.height,
                    color: '#8B4513',
                    type: 'west',
                    rotated: true
                });
                
                // East wall
                game.house.walls.push({
                    x: room.x + room.width, y: room.y, z: 0,
                    width: room.height3D, height: room.height,
                    color: '#8B4513',
                    type: 'east',
                    rotated: true
                });
            });
            
            // Add doors (openings in walls)
            game.house.doors = [
                // Front door (exit)
                {x: 450, y: 0, z: 0, width: 100, height: 200, locked: true, type: 'exit'},
                // Living room door
                {x: 1000, y: 400, z: 0, width: 80, height: 180, locked: false},
                // Kitchen door
                {x: 400, y: 1000, z: 0, width: 80, height: 180, locked: false},
                // Study door
                {x: 1000, y: 1100, z: 0, width: 80, height: 180, locked: false}
            ];
            
            // Add windows
            game.house.windows = [
                {x: 200, y: 0, z: 100, width: 150, height: 150},
                {x: 1200, y: 200, z: 100, width: 150, height: 150},
                {x: 400, y: 1000, z: 100, width: 150, height: 150, type: 'kitchen'},
                {x: 1300, y: 800, z: 100, width: 150, height: 150, type: 'study'}
            ];
            
            // Add furniture
            game.house.furniture = [
                // Living room furniture
                {x: 1100, y: 200, z: 0, width: 200, height: 400, depth: 100, type: 'sofa', color: '#8B0000'},
                {x: 1400, y: 200, z: 0, width: 150, height: 150, depth: 80, type: 'table', color: '#654321'},
                {x: 1300, y: 600, z: 0, width: 250, height: 100, depth: 250, type: 'cabinet', color: '#2F4F4F'},
                
                // Kitchen furniture
                {x: 200, y: 1200, z: 0, width: 300, height: 80, depth: 80, type: 'counter', color: '#696969'},
                {x: 600, y: 1200, z: 0, width: 150, height: 150, depth: 80, type: 'table', color: '#8B4513'},
                
                // Study furniture
                {x: 1200, y: 900, z: 0, width: 200, height: 100, depth: 80, type: 'desk', color: '#654321'},
                {x: 1400, y: 900, z: 0, width: 80, height: 200, depth: 50, type: 'bookshelf', color: '#2F4F4F'},
                
                // Hallway table
                {x: 850, y: 800, z: 0, width: 100, height: 50, depth: 50, type: 'table', color: '#8B4513'}
            ];
            
            // Place keys in the house
            game.keys = [
                {x: 1200, y: 300, z: 50, collected: false, room: 'living'},
                {x: 300, y: 1200, z: 50, collected: false, room: 'kitchen'},
                {x: 1250, y: 950, z: 50, collected: false, room: 'study'},
                {x: 900, y: 400, z: 50, collected: false, room: 'hallway'},
                {x: 1500, y: 100, z: 50, collected: false, room: 'living'}
            ];
            
            // Set player starting position in entry hall
            game.player.x = 500;
            game.player.y = 500;
            game.player.z = 50;
            game.player.angle = 0;
            
            // Set enemy starting position
            game.enemy.x = 1400;
            game.enemy.y = 1400;
            game.enemy.z = 50;
            game.enemy.chasing = false;
            
            // Reset player stats
            game.player.health = 100;
            game.player.keys = 0;
            game.player.sanctuary = 3;
            game.player.stamina = 100;
            
            // Update UI
            updateUI();
        }
        
        // Start the game
        function startGame() {
            game.started = true;
            startScreen.style.display = 'none';
            
            // Request pointer lock for mouse controls
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
        }
        
        // Restart the game
        function restartGame() {
            game.gameOver = false;
            game.won = false;
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            
            // Rebuild house and reset positions
            buildHouse();
            
            // Start with flashlight on
            game.player.flashlightOn = true;
            flashlightIcon.innerHTML = '<span>ðŸ”¦</span> FLASHLIGHT: ON';
            game.darkness = 0.8;
        }
        
        // Toggle sound
        function toggleSound() {
            game.soundEnabled = !game.soundEnabled;
            soundToggle.textContent = game.soundEnabled ? 'ðŸ”Š SOUND ON' : 'ðŸ”‡ SOUND OFF';
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            game.keysPressed[key] = true;
            
            if (!game.started || game.gameOver || game.won) return;
            
            switch(key) {
                case 'f':
                    toggleFlashlight();
                    break;
                case 'e':
                    interact();
                    break;
                case ' ':
                    useSanctuary();
                    break;
                case 'escape':
                    // Pause menu could be added here
                    break;
            }
        }
        
        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            game.keysPressed[key] = false;
        }
        
        // Handle mouse movement
        function handleMouseMove(e) {
            if (!game.started || game.gameOver || game.won) return;
            
            const movementX = e.movementX || e.mozMovementX || 0;
            const movementY = e.movementY || e.mozMovementY || 0;
            
            game.player.angle += movementX * game.mouseSensitivity;
            game.player.tilt += movementY * game.mouseSensitivity * 0.5;
            
            // Clamp tilt
            game.player.tilt = Math.max(-Math.PI/4, Math.min(Math.PI/4, game.player.tilt));
            
            // Normalize angle
            if (game.player.angle > Math.PI * 2) game.player.angle -= Math.PI * 2;
            if (game.player.angle < 0) game.player.angle += Math.PI * 2;
        }
        
        // Toggle flashlight
        function toggleFlashlight() {
            if (game.player.hasFlashlight) {
                game.player.flashlightOn = !game.player.flashlightOn;
                flashlightIcon.innerHTML = game.player.flashlightOn ? 
                    '<span>ðŸ”¦</span> FLASHLIGHT: ON' : 
                    '<span>ðŸ”¦</span> FLASHLIGHT: OFF';
                game.darkness = game.player.flashlightOn ? 0.6 : 0.95;
            }
        }
        
        // Use sanctuary
        function useSanctuary() {
            if (game.player.sanctuary > 0 && game.enemy.chasing) {
                game.player.sanctuary--;
                game.enemy.chasing = false;
                game.enemy.x = 1400;
                game.enemy.y = 1400;
                updateUI();
                
                // Visual effect
                game.darkness = 0.3;
                setTimeout(() => {
                    game.darkness = game.player.flashlightOn ? 0.6 : 0.95;
                }, 1000);
            }
        }
        
        // Interact with objects
        function interact() {
            // Check for keys
            for (const key of game.keys) {
                if (!key.collected) {
                    const dx = key.x - game.player.x;
                    const dy = key.y - game.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 60) {
                        key.collected = true;
                        game.player.keys++;
                        updateUI();
                        
                        if (game.player.keys === game.player.maxKeys) {
                            objectiveEl.textContent = "You have all keys! Find the front door to escape!";
                            objectiveEl.style.color = "#0f0";
                            objectiveEl.classList.add('pulse');
                        } else {
                            objectiveEl.textContent = `Keys found: ${game.player.keys}/${game.player.maxKeys} - Keep searching the house`;
                        }
                        return;
                    }
                }
            }
            
            // Check for exit door
            const exitDoor = game.house.doors.find(door => door.type === 'exit');
            const dx = exitDoor.x - game.player.x;
            const dy = exitDoor.y - game.player.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < 100) {
                if (game.player.keys >= game.player.maxKeys) {
                    // Win the game
                    game.won = true;
                    winScreen.style.display = 'flex';
                } else {
                    objectiveEl.textContent = `The door is locked. Need ${game.player.maxKeys - game.player.keys} more key(s)`;
                    objectiveEl.style.color = "#f00";
                    objectiveEl.classList.add('shake');
                    setTimeout(() => {
                        objectiveEl.classList.remove('shake');
                        objectiveEl.textContent = `Keys found: ${game.player.keys}/${game.player.maxKeys} - Keep searching the house`;
                        objectiveEl.style.color = "#0f0";
                    }, 2000);
                }
            }
        }
        
        // Update player movement
        function updatePlayer(deltaTime) {
            // Determine movement direction
            let moveX = 0;
            let moveY = 0;
            
            if (game.keysPressed['w']) {
                moveX += Math.cos(game.player.angle);
                moveY += Math.sin(game.player.angle);
            }
            if (game.keysPressed['s']) {
                moveX -= Math.cos(game.player.angle);
                moveY -= Math.sin(game.player.angle);
            }
            if (game.keysPressed['a']) {
                moveX += Math.cos(game.player.angle - Math.PI/2);
                moveY += Math.sin(game.player.angle - Math.PI/2);
            }
            if (game.keysPressed['d']) {
                moveX += Math.cos(game.player.angle + Math.PI/2);
                moveY += Math.sin(game.player.angle + Math.PI/2);
            }
            
            // Normalize diagonal movement
            const length = Math.sqrt(moveX*moveX + moveY*moveY);
            if (length > 0) {
                moveX /= length;
                moveY /= length;
            }
            
            // Apply speed
            let speed = game.player.speed;
            game.player.isRunning = false;
            
            if (game.keysPressed['shift'] && game.player.stamina > 0) {
                speed *= 1.8;
                game.player.isRunning = true;
                game.player.stamina = Math.max(0, game.player.stamina - 50 * deltaTime);
            } else if (!game.keysPressed['shift']) {
                game.player.stamina = Math.min(game.player.maxStamina, game.player.stamina + 30 * deltaTime);
            }
            
            // Update stamina display
            staminaFill.style.width = (game.player.stamina / game.player.maxStamina * 100) + '%';
            
            // Calculate new position
            const newX = game.player.x + moveX * speed * deltaTime * 60;
            const newY = game.player.y + moveY * speed * deltaTime * 60;
            
            // Check collision with walls and furniture
            if (!checkCollision(newX, game.player.y)) {
                game.player.x = newX;
            }
            if (!checkCollision(game.player.x, newY)) {
                game.player.y = newY;
            }
        }
        
        // Check collision
        function checkCollision(x, y) {
            const playerRadius = 30;
            
            // Check walls (excluding door openings)
            for (const wall of game.house.walls) {
                // Skip if there's a door in this wall section
                let hasDoor = false;
                for (const door of game.house.doors) {
                    if (wall.type === 'south' && door.y === wall.y) {
                        if (x > door.x - door.width/2 && x < door.x + door.width/2) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                if (hasDoor) continue;
                
                let wallLeft, wallRight, wallTop, wallBottom;
                
                if (wall.rotated) {
                    wallLeft = wall.x;
                    wallRight = wall.x + wall.width;
                    wallTop = wall.y;
                    wallBottom = wall.y + wall.height;
                } else {
                    wallLeft = wall.x;
                    wallRight = wall.x + wall.width;
                    wallTop = wall.y;
                    wallBottom = wall.y + wall.height;
                }
                
                // Circle-rectangle collision
                const closestX = Math.max(wallLeft, Math.min(x, wallRight));
                const closestY = Math.max(wallTop, Math.min(y, wallBottom));
                const distance = Math.sqrt(
                    Math.pow(x - closestX, 2) + 
                    Math.pow(y - closestY, 2)
                );
                
                if (distance < playerRadius) {
                    return true;
                }
            }
            
            // Check furniture
            for (const furniture of game.house.furniture) {
                const left = furniture.x - furniture.width/2;
                const right = furniture.x + furniture.width/2;
                const top = furniture.y - furniture.height/2;
                const bottom = furniture.y + furniture.height/2;
                
                const closestX = Math.max(left, Math.min(x, right));
                const closestY = Math.max(top, Math.min(y, bottom));
                const distance = Math.sqrt(
                    Math.pow(x - closestX, 2) + 
                    Math.pow(y - closestY, 2)
                );
                
                if (distance < playerRadius + Math.min(furniture.width, furniture.height)/2) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Update enemy AI
        function updateEnemy(deltaTime) {
            const dx = game.player.x - game.enemy.x;
            const dy = game.player.y - game.enemy.y;
            game.enemyDistance = Math.sqrt(dx*dx + dy*dy);
            
            // Update warning
            if (game.enemyDistance < 200 && game.enemy.chasing) {
                warningEl.style.display = 'block';
                const intensity = 1 - (game.enemyDistance / 200);
                warningEl.style.fontSize = 32 + intensity * 24 + 'px';
                warningEl.style.opacity = intensity;
            } else {
                warningEl.style.display = 'none';
            }
            
            // Enemy behavior
            if (!game.enemy.chasing) {
                // Patrol mode
                if (game.enemyDistance < game.enemy.detectionRange) {
                    game.enemy.chasing = true;
                    game.enemy.lastSeenTime = Date.now();
                }
            } else {
                // Chase mode
                if (Date.now() - game.enemy.lastSeenTime > 8000) {
                    game.enemy.chasing = false;
                } else {
                    // Move towards player
                    const angle = Math.atan2(dy, dx);
                    const enemySpeed = game.enemy.speed * deltaTime * 60;
                    
                    game.enemy.x += Math.cos(angle) * enemySpeed;
                    game.enemy.y += Math.sin(angle) * enemySpeed;
                    
                    // Check attack
                    if (game.enemyDistance < game.enemy.attackRange) {
                        attackPlayer();
                    }
                    
                    // Update last seen time
                    if (game.enemyDistance < game.enemy.chaseRange) {
                        game.enemy.lastSeenTime = Date.now();
                    }
                }
            }
        }
        
        // Attack player
        function attackPlayer() {
            game.player.health -= 20;
            updateUI();
            
            // Visual feedback
            document.body.classList.add('shake');
            setTimeout(() => {
                document.body.classList.remove('shake');
            }, 500);
            
            // Check game over
            if (game.player.health <= 0) {
                game.player.health = 0;
                game.gameOver = true;
                gameOverScreen.style.display = 'flex';
            }
        }
        
        // Update UI
        function updateUI() {
            healthValue.textContent = Math.max(0, game.player.health);
            keysValue.textContent = `${game.player.keys}/${game.player.maxKeys}`;
            sanctuaryValue.textContent = game.player.sanctuary;
            
            // Update health color
            if (game.player.health > 60) {
                healthValue.style.color = '#0f0';
            } else if (game.player.health > 30) {
                healthValue.style.color = '#ff0';
            } else {
                healthValue.style.color = '#f00';
                healthValue.classList.add('pulse');
            }
        }
        
        // 3D rendering functions
        function draw3D() {
            // Clear canvas with dark blue-black gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#001122');
            gradient.addColorStop(1, '#000811');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate camera parameters
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const fov = Math.PI / 3;
            const scale = canvas.height / (2 * Math.tan(fov / 2));
            
            // Draw floor
            drawFloor(centerX, centerY, scale);
            
            // Draw ceilings
            drawCeilings(centerX, centerY, scale);
            
            // Draw walls
            drawWalls3D(centerX, centerY, scale);
            
            // Draw furniture
            drawFurniture3D(centerX, centerY, scale);
            
            // Draw doors and windows
            drawDoorsWindows(centerX, centerY, scale);
            
            // Draw keys
            drawKeys3D(centerX, centerY, scale);
            
            // Draw enemy
            drawEnemy3D(centerX, centerY, scale);
            
            // Apply darkness overlay
            ctx.fillStyle = `rgba(0, 0, 0, ${game.darkness})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw flashlight effect if on
            if (game.player.flashlightOn) {
                const flashlightGradient = ctx.createRadialGradient(
                    centerX, centerY + game.player.tilt * 100, 100,
                    centerX, centerY + game.player.tilt * 100, 600
                );
                flashlightGradient.addColorStop(0, 'rgba(255, 255, 200, 0.15)');
                flashlightGradient.addColorStop(0.5, 'rgba(255, 255, 180, 0.05)');
                flashlightGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = flashlightGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        // Draw floor
        function drawFloor(centerX, centerY, scale) {
            ctx.fillStyle = '#2F4F4F'; // Dark slate gray
            ctx.fillRect(0, centerY, canvas.width, canvas.height - centerY);
            
            // Add wood floor texture
            ctx.strokeStyle = '#3D2B1F';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, centerY);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            for (let i = centerY; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }
        
        // Draw ceilings
        function drawCeilings(centerX, centerY, scale) {
            ctx.fillStyle = '#1A1A1A';
            ctx.fillRect(0, 0, canvas.width, centerY);
            
            // Add ceiling texture (beams)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 3;
            
            for (let i = 0; i < canvas.width; i += 120) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, centerY);
                ctx.stroke();
            }
        }
        
        // Draw 3D walls
        function drawWalls3D(centerX, centerY, scale) {
            // Sort walls by distance for proper rendering
            const walls = [...game.house.walls].sort((a, b) => {
                const distA = Math.sqrt(
                    Math.pow(a.x - game.player.x, 2) + 
                    Math.pow(a.y - game.player.y, 2)
                );
                const distB = Math.sqrt(
                    Math.pow(b.x - game.player.x, 2) + 
                    Math.pow(b.y - game.player.y, 2)
                );
                return distB - distA; // Draw farthest first
            });
            
            walls.forEach(wall => {
                const dx = wall.x - game.player.x;
                const dy = wall.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 1000) { // Render distance limit
                    const angle = Math.atan2(dy, dx) - game.player.angle;
                    
                    // Check if wall is in field of view
                    if (Math.abs(angle) < Math.PI / 2) {
                        // Project 3D coordinates to 2D screen
                        const screenX = centerX + (angle * scale);
                        
                        // Calculate wall height on screen
                        const wallHeight = (wall.height / distance) * scale;
                        const wallWidth = (wall.width / distance) * scale;
                        
                        // Calculate screen position
                        const screenY = centerY - wallHeight / 2 + game.player.tilt * 100;
                        
                        // Draw wall
                        ctx.fillStyle = wall.color;
                        ctx.fillRect(screenX - wallWidth/2, screenY, wallWidth, wallHeight);
                        
                        // Add wall texture
                        ctx.strokeStyle = wall.color === '#A0522D' ? '#8B4513' : '#A0522D';
                        ctx.lineWidth = 2;
                        
                        if (!wall.rotated) {
                            // Horizontal wall texture (boards)
                            for (let i = 0; i < wallHeight; i += 20) {
                                ctx.beginPath();
                                ctx.moveTo(screenX - wallWidth/2, screenY + i);
                                ctx.lineTo(screenX + wallWidth/2, screenY + i);
                                ctx.stroke();
                            }
                        } else {
                            // Vertical wall texture
                            for (let i = 0; i < wallWidth; i += 20) {
                                ctx.beginPath();
                                ctx.moveTo(screenX - wallWidth/2 + i, screenY);
                                ctx.lineTo(screenX - wallWidth/2 + i, screenY + wallHeight);
                                ctx.stroke();
                            }
                        }
                    }
                }
            });
        }
        
        // Draw 3D furniture
        function drawFurniture3D(centerX, centerY, scale) {
            game.house.furniture.forEach(furniture => {
                const dx = furniture.x - game.player.x;
                const dy = furniture.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 600) {
                    const angle = Math.atan2(dy, dx) - game.player.angle;
                    
                    if (Math.abs(angle) < Math.PI / 2) {
                        const screenX = centerX + (angle * scale);
                        const height = (furniture.depth / distance) * scale;
                        const width = (furniture.width / distance) * scale;
                        const depth = (furniture.height / distance) * scale;
                        
                        const screenY = centerY - height / 2 + game.player.tilt * 100 + (50 / distance) * scale;
                        
                        // Draw furniture
                        ctx.fillStyle = furniture.color;
                        ctx.fillRect(screenX - width/2, screenY - depth/2, width, depth);
                        
                        // Add 3D effect
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(screenX - width/2, screenY - depth/2, width, depth);
                        
                        // Draw top of furniture
                        ctx.fillStyle = furniture.type === 'table' ? '#8B4513' : 
                                       furniture.type === 'cabinet' ? '#2F4F4F' : furniture.color;
                        ctx.fillRect(screenX - width/2, screenY - depth/2 - height/4, width, height/4);
                    }
                }
            });
        }
        
        // Draw doors and windows
        function drawDoorsWindows(centerX, centerY, scale) {
            // Draw doors
            game.house.doors.forEach(door => {
                const dx = door.x - game.player.x;
                const dy = door.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 500) {
                    const angle = Math.atan2(dy, dx) - game.player.angle;
                    
                    if (Math.abs(angle) < Math.PI / 2) {
                        const screenX = centerX + (angle * scale);
                        const height = (door.height / distance) * scale;
                        const width = (door.width / distance) * scale;
                        
                        const screenY = centerY - height / 2 + game.player.tilt * 100;
                        
                        // Draw door
                        ctx.fillStyle = door.type === 'exit' ? 
                            (game.player.keys >= game.player.maxKeys ? '#0a0' : '#a00') : 
                            '#654321';
                        ctx.fillRect(screenX - width/2, screenY, width, height);
                        
                        // Add door details
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX - width/2, screenY, width, height);
                        
                        // Draw doorknob
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(screenX + width/4, screenY + height/2, width/8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            // Draw windows
            game.house.windows.forEach(window => {
                const dx = window.x - game.player.x;
                const dy = window.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 400) {
                    const angle = Math.atan2(dy, dx) - game.player.angle;
                    
                    if (Math.abs(angle) < Math.PI / 2) {
                        const screenX = centerX + (angle * scale);
                        const size = (window.width / distance) * scale;
                        
                        const screenY = centerY - size/2 + game.player.tilt * 100 + (100 / distance) * scale;
                        
                        // Draw window
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
                        ctx.fillRect(screenX - size/2, screenY, size, size);
                        
                        // Draw window frame
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(screenX - size/2, screenY, size, size);
                        
                        // Draw window cross
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX, screenY + size);
                        ctx.moveTo(screenX - size/2, screenY + size/2);
                        ctx.lineTo(screenX + size/2, screenY + size/2);
                        ctx.stroke();
                    }
                }
            });
        }
        
        // Draw 3D keys
        function drawKeys3D(centerX, centerY, scale) {
            game.keys.forEach(key => {
                if (!key.collected) {
                    const dx = key.x - game.player.x;
                    const dy = key.y - game.player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 300) {
                        const angle = Math.atan2(dy, dx) - game.player.angle;
                        
                        if (Math.abs(angle) < Math.PI / 2) {
                            const screenX = centerX + (angle * scale);
                            const size = Math.max(10, (30 / distance) * scale);
                            
                            const screenY = centerY - size/2 + game.player.tilt * 100 + (50 / distance) * scale;
                            
                            // Draw glowing key
                            const gradient = ctx.createRadialGradient(
                                screenX, screenY, size/2,
                                screenX, screenY, size
                            );
                            gradient.addColorStop(0, '#ff0');
                            gradient.addColorStop(0.7, '#ff0');
                            gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Draw key shape
                            ctx.fillStyle = '#ff0';
                            ctx.fillRect(screenX - size/4, screenY - size/8, size/2, size/4);
                            ctx.beginPath();
                            ctx.arc(screenX + size/4, screenY, size/8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            });
        }
        
        // Draw 3D enemy
        function drawEnemy3D(centerX, centerY, scale) {
            const dx = game.enemy.x - game.player.x;
            const dy = game.enemy.y - game.player.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < 400) {
                const angle = Math.atan2(dy, dx) - game.player.angle;
                
                if (Math.abs(angle) < Math.PI / 2) {
                    const screenX = centerX + (angle * scale);
                    const size = Math.max(20, (80 / distance) * scale);
                    
                    const screenY = centerY - size/2 + game.player.tilt * 100 + (50 / distance) * scale;
                    
                    // Draw enemy shadow
                    const shadowGradient = ctx.createRadialGradient(
                        screenX, screenY, size/2,
                        screenX, screenY, size * 1.5
                    );
                    shadowGradient.addColorStop(0, 'rgba(150, 0, 0, 0.8)');
                    shadowGradient.addColorStop(1, 'rgba(50, 0, 0, 0)');
                    
                    ctx.fillStyle = shadowGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw enemy body
                    const enemyGradient = ctx.createRadialGradient(
                        screenX, screenY, size/4,
                        screenX, screenY, size
                    );
                    enemyGradient.addColorStop(0, game.enemy.chasing ? '#f00' : '#800');
                    enemyGradient.addColorStop(1, 'rgba(100, 0, 0, 0.5)');
                    
                    ctx.fillStyle = enemyGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw eyes when chasing
                    if (game.enemy.chasing) {
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(screenX - size/3, screenY - size/6, size/6, 0, Math.PI * 2);
                        ctx.arc(screenX + size/3, screenY - size/6, size/6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw red pupils
                        ctx.fillStyle = '#f00';
                        ctx.beginPath();
                        ctx.arc(screenX - size/3, screenY - size/6, size/10, 0, Math.PI * 2);
                        ctx.arc(screenX + size/3, screenY - size/6, size/10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        // Game loop
        function gameLoop(currentTime) {
            // Calculate delta time
            const deltaTime = (currentTime - game.lastTime) / 1000 || 0;
            game.lastTime = currentTime;
            
            // Update game state
            if (game.started && !game.gameOver && !game.won) {
                updatePlayer(deltaTime);
                updateEnemy(deltaTime);
            }
            
            // Draw 3D scene
            draw3D();
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Initialize the game
        window.addEventListener('load', init);
    </script>
</body>
</html>
